<h1><a id="X7c7e815dd7d8bcac1e447d753b9ac7db0907bae"></a>Arc 2: Memory &amp; Storage — FINAL COMPLETE SCRIPT (v5.4)</h1><h2><a id="video-6-storing-data-in-memory"></a>Video 6: Storing Data in Memory</h2><p><strong>Duration:</strong> ~150–160 seconds<br /><strong>Concept:</strong> Variables are named storage containers</p><h3><a id="slide-1-title-screen"></a>[SLIDE 1: Title Screen]</h3><p><strong>Visual:</strong> “Video 6: Storing Data in Memory”<br /><strong>Audio:</strong><br />“You’re building a game and need to remember the player’s username, score, and level. Print them once? They’re gone. You need to store data so you can use it throughout your code. That’s what variables do—Python’s little memory system.”</p><p><strong>[10 seconds]</strong></p><h3><a id="slide-2-the-hardcode-trap"></a>[SLIDE 2: The Hardcode Trap]</h3><p><strong>Visual:</strong></p><p># Hardcoded name everywhere...<br /># ...and imagine 50 more lines like this.<br />print("Welcome, Shadow_Blade!")<br />print("Shadow_Blade leveled up!")<br />print("Shadow_Blade defeated the boss!")<br />print("Shadow_Blade's score: 1000")</p><p><strong>Audio:</strong><br />“Imagine you hardcode your character’s name everywhere in your game: welcome messages, level-up notifications, boss defeats—and imagine 50 more lines like this. This works… until you change your mind. And you will. Because naming a character is a sacred ritual: you pick something cool, then immediately regret it. Without variables, you have to hunt down every single mention and change it manually. Miss even one line and your game becomes inconsistent.”</p><p><strong>[22 seconds]</strong></p><h3><a id="slide-3-the-missed-one-bug"></a>[SLIDE 3: The “Missed One” Bug]</h3><p><strong>Visual:</strong></p><p># Rename time! Shadow_Blade -&gt; Dragon_Slayer<br />print("Welcome, Dragon_Slayer!")<br />print("Shadow_Blade leveled up!")  # &lt;-- OOPS. Missed one.<br />print("Dragon_Slayer defeated the boss!")<br />print("Dragon_Slayer's score: 1000")</p><p><strong>Audio:</strong><br />“This is the classic bug: you update most lines, miss one, and now your game has identity issues. It’s not broken in a dramatic way—it’s broken in an embarrassing way.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-4-the-variable-fix-solution-power"></a>[SLIDE 4: The Variable Fix (Solution &amp; Power)]</h3><p><strong>Visual:</strong></p><p># Before (Hardcoded chaos):<br />print("Welcome, Shadow_Blade!")<br />print("Shadow_Blade leveled up!")<br /><br /># After (Variables rule):<br />character_name = "Dragon_Slayer"  # ONE change<br /><br />print("Welcome,", character_name)<br />print(character_name, "leveled up!")<br />print(character_name, "defeated the boss!")</p><p><strong>Audio:</strong><br />“With variables, you store the name once, then reuse it everywhere. Now changing the character name is one edit, not a scavenger hunt. Change one line at the top, and the whole game updates. That’s the real power of variables: update in one place, affect everything.”</p><p><strong>[20 seconds]</strong></p><h3><a id="X548c82885818f03b556c65240be9dbbbf31fa02"></a>[SLIDE 5: Real-World Analogy — Best Friend Contact]</h3><p><strong>Visual:</strong> Contact card: Best Friend → phone number, birthday, favorite snack<br /><strong>Audio:</strong><br />“Variables are like saving your best friend’s contact. You don’t memorize their phone number—because you’d get it wrong, call the wrong person, and have an awkward conversation. You save it once as ‘Best Friend’ and use it forever. When they change their number, you update it once and every call uses the new number. Same idea: store important information once, reference it everywhere.”</p><p><strong>[18 seconds]</strong></p><h3><a id="slide-6-creating-your-first-variable"></a>[SLIDE 6: Creating Your First Variable]</h3><p><strong>Visual:</strong></p><p>favorite_snack = "Kale Chips"</p><p><strong>Audio:</strong><br />“Creating a variable is simple. Pick a name—like favorite_snack—use the equals sign, then provide the value. This is called assignment. You’re telling Python: ‘Whenever I say favorite_snack, I mean Kale Chips.’ We’re definitely lying to ourselves, but Python trusts us.”</p><p><strong>[16 seconds]</strong></p><h3><a id="X95ea782285b295a8929a1818b673bb0c96a1401"></a>[SLIDE 7: Variables Hold Different Types (Backpack Pockets)]</h3><p><strong>Visual:</strong> Backpack cutaway with pockets: phone (string), laptop (number: 1), water bottle (float: 0.5L), and a <strong>mystery sandwich with visible mold</strong> in a hidden pocket (boolean: True for contains mystery).<br /><strong>Code:</strong></p><p>game_title = "CodeStrike"      # String<br />max_players = 100              # Integer<br />progress = 87.5                # Float<br />is_multiplayer = True          # Boolean</p><p><strong>Audio:</strong><br /></p><p>"Variables can store different kinds of data, like pockets in a backpack. Phone in one pocket, laptop in another, water bottle on the side, and that mystery sandwich from last week in the hidden pocket—we're not opening that. Each pocket just holds what you put in. Variables do the same thing."</p><p><strong>[28 seconds]</strong></p><h3><a id="slide-8-the-assignment-symbol"></a>[SLIDE 8: The Assignment Symbol]</h3><p><strong>Visual:</strong></p><p>level = 5</p><p><strong>On-screen note:</strong> “Take 5 → store it in level”<br /><strong>Audio:</strong><br />“Important: the equals sign isn’t saying ‘level IS 5’ like a math fact. It’s an instruction. Here’s what Python does: First, it looks at the right side and grabs the value 5. Then it stores that 5 into the variable called level. Right side first, then store in the left side. That’s the pattern every time.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-9-variables-vs-direct-values"></a>[SLIDE 9: Variables vs Direct Values]</h3><p><strong>Visual:</strong></p><p># Direct value (one-time):<br />print("Visit my channel!")  # shows once, then it's gone<br /><br /># Variable (stored and reused):<br />channel_message = "Visit my channel!"<br />print(channel_message)<br />print(channel_message)<br />print(channel_message)</p><p><strong>Audio:</strong><br />“Printing a value directly is like a Snapchat message. It appears once, then vanishes. Variables are like saving it to your camera roll—you store it once, then reuse it anywhere. We stored the message in channel_message, and now we can print it three times without retyping.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-10-key-takeaway"></a>[SLIDE 10: Key Takeaway]</h3><p><strong>Visual:</strong></p><p>variable_name = value<br /># Name = what you call it<br /># Value = what it remembers</p><p><strong>Audio:</strong><br />“Variables are named storage containers. Store a value once, then reuse it by name anywhere in your program. Update it in one place, and everything that uses it updates too.”</p><p><strong>[10 seconds]</strong></p><p><strong>Total: ~157 seconds</strong></p><h2><a id="video-7-changing-stored-values"></a>Video 7: Changing Stored Values</h2><p><strong>Duration:</strong> ~135 seconds<br /><strong>Concept:</strong> Variables can be updated (overwritten)</p><h3><a id="slide-1-title-screen-1"></a>[SLIDE 1: Title Screen]</h3><p><strong>Visual:</strong> “Video 7: Changing Stored Values”<br /><strong>Audio:</strong><br />“Real data changes constantly. Your score changes, your battery changes, your mood changes after ‘one more video.’ Variables aren’t permanent—you can update them whenever you want.”</p><p><strong>[10 seconds]</strong></p><h3><a id="slide-2-the-replacement-rule"></a>[SLIDE 2: The Replacement Rule]</h3><p><strong>Visual:</strong></p><p>score = 100<br />score = 200  # What happened to 100?</p><p><strong>Audio:</strong><br />“Key rule: when you assign a new value to a variable, the old value is replaced. Not saved. Not archived. Gone. Variables don’t keep memories—ironic, I know. That’s actually why they’re called variables—because the value inside can vary. It’s not locked forever. The old value gets deleted like you never existed. Dramatic, but true.”</p><p><strong>[20 seconds]</strong></p><h3><a id="Xe34c39a298b011eb889d42669a58896f37b8f65"></a>[SLIDE 3: Real-World Analogy — Whiteboard]</h3><p><strong>Visual</strong>: Whiteboard showing: 1. “TODO: Study Python” (crossed out) 2. “TODO: Watch Cat Videos” (written in)</p><p><strong>Audio</strong>:</p><p><em>“Think of a variable like a whiteboard. You write ‘Study Python’ on it with determination. Then reality hits. You erase it and write ‘Watch Cat Videos’ because priorities shift. The old text disappears, new text takes its place. Variables work exactly like that: assign a new value, the old one vanishes.”</em></p><p><strong>[15 seconds]</strong></p><h3><a id="slide-4-step-by-step-update-tabs"></a>[SLIDE 4: Step-by-Step Update (Tabs)]</h3><p><strong>Visual:</strong></p><p>youtube_tabs = 1<br />print(youtube_tabs)<br /><br />youtube_tabs = 5<br />print(youtube_tabs)<br /><br />youtube_tabs = 23<br />print(youtube_tabs)</p><p><strong>Output:</strong></p><p>1<br />5<br />23</p><p><strong>Audio:</strong><br />“Let’s track something we all understand: YouTube tabs. Start with 1 tab open—you’re being responsible. Print shows 1. Then ‘just one more video’ happens. We assign youtube_tabs = 5. That overwrites the 1—it’s gone. Print shows 5. An hour later? We assign youtube_tabs = 23 and your browser is crying for mercy. The 5 gets replaced. Print shows 23. Same variable, but each new assignment completely overwrites what was there before. Python doesn’t judge your tab addiction.”</p><p><strong>[20 seconds]</strong></p><h3><a id="slide-5-using-the-current-value"></a>[SLIDE 5: Using the Current Value]</h3><p><strong>Visual:</strong></p><p>followers = 100<br />print(followers)  # 100<br /><br />followers = followers + 50<br />print(followers)  # 150</p><p><strong>Output:</strong></p><p>100<br />150</p><p><strong>Audio:</strong><br />“Here’s where it gets powerful: you can use a variable’s current value to calculate its new value. Followers starts at 100. Then we say: followers equals followers plus 50. Python reads the RIGHT side first—looks up followers, sees 100, adds 50, gets 150. Then it stores that 150 back into followers. The old 100? Replaced. Now when we print, we see 150. It’s the same variable, just updated with math.”</p><p><strong>[22 seconds]</strong></p><h3><a id="slide-6-xp-pattern-games"></a>[SLIDE 6: XP Pattern (Games)]</h3><p><strong>Visual:</strong></p><p>xp = 0<br /># You defeated an enemy!<br />xp = xp + 10<br />print(xp)  # 10<br /><br /># You defeated another enemy!<br />xp = xp + 10<br />print(xp)  # 20</p><p><strong>Output:</strong></p><p>10<br />20</p><p><strong>Audio:</strong><br />“This pattern is everywhere in games. You start with 0 XP. You defeat an enemy. We do: xp equals xp plus 10. Python evaluates the right side first—0 plus 10 equals 10—then shoves that back into xp. Print shows 10. Defeat another enemy, same code runs again. Python reads xp—now 10—adds 10, gets 20, stores it back. The 10 gets overwritten. We’re not getting a new XP bar each time; the old value just keeps getting replaced.”</p><p><strong>[24 seconds]</strong></p><h3><a id="slide-7-phone-battery"></a>[SLIDE 7: Phone Battery]</h3><p><strong>Visual:</strong> Battery 100% → 50% → 20% → 1%<br /><strong>Audio:</strong><br />“Your phone battery is basically a variable. Same battery icon, different value inside—and somehow it always drops faster when you need it most.”</p><p><strong>[10 seconds]</strong></p><h3><a id="slide-8-key-takeaway"></a>[SLIDE 8: Key Takeaway]</h3><p><strong>Visual:</strong></p><p>x = 5<br />x = 10      # 5 is gone<br />x = x + 1   # Now 11</p><p><strong>Audio:</strong><br />“Variables update constantly. New values replace old ones. And you can use the current value to compute the next value. That’s how programs track a changing world.”</p><p><strong>[10 seconds]</strong></p><p><strong>Total: ~135 seconds</strong></p><h2><a id="video-8-naming-rules"></a>Video 8: Naming Rules</h2><p><strong>Duration:</strong> ~135 seconds<br /><strong>Concept:</strong> Variable names follow rules (and good style saves you later)</p><h3><a id="slide-1-title-screen-2"></a>[SLIDE 1: Title Screen]</h3><p><strong>Visual:</strong> “Video 8: Naming Rules”<br /><strong>Audio:</strong><br />“You want variables for score, username, level, and everything else. But Python is picky about names. Use the wrong format and your code crashes instantly. Let’s learn the rules so Python doesn’t have a meltdown.”</p><p><strong>[10 seconds]</strong></p><h3><a id="slide-2-the-club-bouncer"></a>[SLIDE 2: The Club Bouncer]</h3><p><strong>Visual:</strong> Python as a bouncer with a clipboard<br /><strong>Audio:</strong><br />“Python is like a strict nightclub bouncer. It has a guest list. Your variable name shows up wearing sandals and a hyphen? Not getting in.”</p><p><strong>[14 seconds]</strong></p><h3><a id="X2d7b45bb2db7f6cc3cf62090410b8c285b5bbfa"></a>[SLIDE 3: Rule 1 — Allowed Characters (and why)]</h3><p><strong>Visual:</strong></p><p>player_score = 100   # OK<br />level2_boss = "Dragon"  # OK<br /><br />my-score = 50        # NO<br /># Python thinks: my - score  (subtraction?)<br /><br />my score = 50        # NO<br /># Python thinks: two separate names: my and score</p><p><strong>Audio:</strong><br />“Rule one: only letters, numbers, and underscores. A hyphen looks like subtraction, so Python thinks you’re doing math. A space looks like two separate names. Underscores are the safe connector.”</p><p><strong>[18 seconds]</strong></p><h3><a id="slide-4-rule-2-dont-start-with-a-number"></a>[SLIDE 4: Rule 2 — Don’t Start With a Number]</h3><p><strong>Visual:</strong></p><p>1st_place = "Me"   # NO<br />place_1 = "Me"     # OK</p><p><strong>Audio:</strong><br />“Rule two: don’t start with a number. Python sees a leading number and assumes you’re doing math, not naming something.”</p><p><strong>[12 seconds]</strong></p><h3><a id="Xa1ea7b5d1b5225bfe3378a3821fd984ece318ee"></a>[SLIDE 5: Rule 3 — Case Sensitivity + Python Convention]</h3><p><strong>Visual:</strong></p><p>score = 100<br />Score = 500<br />SCORE = 9000</p><p><strong>Audio:</strong><br />“Rule three: Python is case-sensitive—these are three different variables. It’s like three people with the same name who get mad if you call them the wrong version. Python convention is to use lowercase_with_underscores, so names like player_score are the usual style.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-6-rule-4-reserved-words-expanded"></a>[SLIDE 6: Rule 4 — Reserved Words (EXPANDED)]</h3><p><strong>Visual:</strong></p><p># This breaks everything:<br />print = "oops"  # NO<br />if = "nope"     # NO<br />for = "never"   # NO</p><p><strong>On-screen comparison:</strong></p><p># This works:<br />print("Hello")  # Python knows: show "Hello"<br /><br /># This breaks everything:<br />print = "oops"<br />print("Hello")  # ERROR - print is now a string, not a command!</p><p><strong>Audio:</strong></p><p>"Rule four: some words are already taken—print, if, for, while. Python called dibs on these. These are words that python uses, so you shouldn’t use them. You have already learned about the print command. The others you will learn soon. "</p><p><strong>[28 seconds]</strong></p><h3><a id="slide-7-good-names-vs-painful-names"></a>[SLIDE 7: Good Names vs Painful Names]</h3><p><strong>Visual:</strong></p><p>player_score = 1500<br />lives_remaining = 3<br /><br />x = 1500<br />n = 3</p><p><strong>Audio:</strong><br />“Beyond the rules: use descriptive names. player_score is clear. <em>But ‘x’? Is that a coordinate? A score? The number of times you’ve rage-quit today? </em> Future you will open this code and whisper: ‘Who wrote this?’ Spoiler: it was you.”</p><p><strong>[18 seconds]</strong></p><h3><a id="slide-8-file-naming-parallel"></a>[SLIDE 8: File Naming Parallel]</h3><p><br /><strong>Visual</strong>: Two file icons: 1. “homework_final_FINAL_v3_REAL.pdf” (confusing mess) 2. “math_assignment_jan_2024.pdf” (clear, organized)</p><p><strong>Audio</strong>:</p><p><em>“It’s like naming computer files. Ever seen a folder full of files named ‘homework_final_FINAL_v3_REAL_actually_final.pdf’? Chaos. Or clear names like ‘math_assignment_jan_2024.pdf’? You find it instantly. Good variable names are self-explanatory—you know what’s inside without guessing.”</em></p><p><strong>[14 seconds]</strong></p><h3><a id="slide-9-key-takeaway"></a>[SLIDE 9: Key Takeaway]</h3><p><strong>Visual:</strong> Rules list + “lowercase_with_underscores”<br /><strong>Audio:</strong><br />“Letters, numbers, underscores. Start with a letter or underscore. Case-sensitive. Avoid reserved words. And choose names that make your code readable.”</p><p><strong>[8 seconds]</strong></p><p><strong>Total: ~135 seconds</strong></p><h2><a id="Xe1fd6b466b428bd868d49143986ad2ee5d97f1d"></a>Video 9.1: Understanding Strings (Why “String”?)</h2><p><strong>Duration:</strong> ~125 seconds<br /><strong>Concept:</strong> Strings are text in quotes</p><h3><a id="slide-1-title-screen-3"></a>[SLIDE 1: Title Screen]</h3><p><strong>Visual:</strong> “Video 9.1: Understanding Strings”<br /><strong>Audio:</strong><br />“In Python, text data is called a String. But why? Let’s break down what strings are, why they have that name, and why you’ll use them constantly.”</p><p><strong>[10 seconds]</strong></p><h3><a id="slide-2-whats-a-string"></a>[SLIDE 2: What’s a String?]</h3><p><strong>Visual:</strong></p><p>username = "NotAHacker"  # Definitely trustworthy<br />status = "this is fine"  # (narrator: it was not fine)<br />item = "Health Potion"   # Actually just water</p><p><strong>Audio:</strong><br />“Strings are text wrapped in quotes. Usernames, messages, item names—anything made of characters is a string. Python doesn’t judge what you type. It just stores it.”</p><p><strong>[15 seconds]</strong></p><h3><a id="slide-3-why-string-beads-metaphor"></a>[SLIDE 3: Why “String”? (Beads Metaphor)]</h3><p><strong>Visual:</strong> H–E–L–L–O as beads on a string<br /><strong>Code:</strong></p><p>greeting = "HELLO"</p><p><strong>Audio:</strong><br />“It’s called a string because it’s a string of characters—like beads on a necklace. HELLO is five characters in order. Somebody way back thought that’s how it looked, and we’ve been living with it ever since. Kind of like how we call it a pineapple even though it’s neither a pine nor an apple. ”</p><p><strong>[22 seconds]</strong></p><h3><a id="slide-4-quotes-freeze-text"></a>[SLIDE 4: Quotes Freeze Text]</h3><p><strong>Visual:</strong></p><p>message = "Hello World"<br />username = "Player1"</p><p><strong>Audio:</strong><br />“Quotes tell Python: ‘Take a time-out—don’t think, just remember exactly what you see.’ The moment Python sees an opening quote, it stops trying to understand or execute anything. It just collects every character—letters, spaces, symbols, whatever—until it sees the closing quote. Then it stores all of that as frozen text. No interpretation. No commands. Just pure text, saved exactly as written.”</p><p><strong>[22 seconds]</strong></p><h3><a id="slide-5-even-math-gets-frozen"></a>[SLIDE 5: Even Math Gets Frozen]</h3><p><strong>Visual:</strong></p><p>calculation = "10 + 5"<br />print(calculation)</p><p><strong>Output:</strong></p><p>10 + 5</p><p><strong>Audio:</strong><br />“Here’s the weird part: even if you put math inside quotes, Python won’t calculate it. It just stores the characters ‘1’, ‘0’, ’ ‘,’+‘,’ ‘, ’5’. You get the text ‘10 + 5’, not the answer 15. Quotes freeze everything into text.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-6-quotes-are-required"></a>[SLIDE 6: Quotes Are Required]</h3><p><strong>Visual:</strong></p><p>name = "Alex"  # OK<br />name = Alex    # ERROR (Python thinks Alex is a variable)</p><p><strong>Audio:</strong><br />“Without quotes, Python assumes you’re referring to a variable named Alex. If Alex doesn’t exist, Python complains. Quotes make it literal text.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-7-key-takeaway"></a>[SLIDE 7: Key Takeaway]</h3><p><strong>Visual:</strong></p><p>"Hello"  # String (text)<br />Hello    # not a string, just a mysterious word to Python</p><p><strong>Audio:</strong><br />“Strings are text in quotes. Quotes freeze text so Python stores it exactly.”</p><p><strong>[10 seconds]</strong></p><p><strong>Total: ~125 seconds</strong></p><h2><a id="Xf0cec0f42d9646b1e75ad3d4cd599ad63efc31c"></a>Video 9.2: Understanding Numbers (Integers &amp; Floats)</h2><p><strong>Duration:</strong> ~115 seconds<br /><strong>Concept:</strong> Integers vs floats, and why mixing types breaks things</p><h3><a id="slide-1-title-screen-4"></a>[SLIDE 1: Title Screen]</h3><p><strong>Visual:</strong> “Video 9.2: Understanding Numbers”<br /><strong>Audio:</strong><br />“Now let’s talk about actual numbers. Python has integers for whole numbers and floats for decimals. Mixing numbers with strings is where the comedy—and the errors—begin.”</p><p><strong>[10 seconds]</strong></p><h3><a id="slide-2-integers-whole-numbers"></a>[SLIDE 2: Integers (Whole Numbers)]</h3><p><strong>Visual:</strong></p><p>lives = 3<br />score = 1000<br />level = 42<br />players_online = 100</p><p><strong>Audio:</strong><br />“Integers are whole numbers. Great for counting: lives, scores, levels, number of players. You can’t have 2.5 lives. That’s not how games—or life—works.”</p><p><strong>[14 seconds]</strong></p><h3><a id="slide-3-floats-decimals"></a>[SLIDE 3: Floats (Decimals)]</h3><p><strong>Visual:</strong></p><p>price = 9.99<br />health = 87.5<br />success_rate = 0.75</p><p><strong>Audio:</strong><br />“Floats are decimals. Great for prices, percentages, and anything that needs precision. That dot is the clue: decimal point equals float.”</p><p><strong>[14 seconds]</strong></p><h3><a id="slide-4-numbers-dont-use-quotes"></a>[SLIDE 4: Numbers Don’t Use Quotes]</h3><p><strong>Visual:</strong></p><p>age = 25      # number<br />age = "25"    # string<br /><br />print(25 + 5)  # OK: 30</p><p><strong>Output:</strong></p><p>30</p><p><strong>Audio:</strong><br />“Critical difference: numbers have no quotes. Put quotes around a number and you’ve turned it into text. Without quotes, 25 plus 5 gives you 30. With quotes, ‘25’ is frozen text—you can’t do math with it. Quotes change everything.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-5-mixing-types-blender"></a>[SLIDE 5: Mixing Types (Blender)]</h3><p><strong>Visual:</strong></p><p>print(10 / 2)        # OK: 5.0<br />print("hello" / 2)   # ERROR</p><p>(Show blender visual: fruit = numbers, rock labeled “Hello” = strings)</p><p><strong>Output:</strong></p><p>5.0<br />TypeError: unsupported operand type(s) for /: 'str' and 'int'</p><p><strong>Audio:</strong><br />“Think of math like a blender. Numbers are fruit—blend smoothly. Strings are rocks—blend that and something breaks. Python doesn’t know what ‘divide text’ means, so it throws a TypeError and stops instead of guessing.”</p><p><strong>[20 seconds]</strong></p><h3><a id="slide-6-when-to-use-which"></a>[SLIDE 6: When to Use Which]</h3><p><strong>Visual:</strong></p><p>lives = 3        # integer<br />rating = 4.5     # float<br />username = "Neo" # string</p><p><strong>Audio:</strong><br />“Simple rule: text in quotes equals string. Whole numbers equal int. Decimals equal float. Match the type to the job and your code behaves.”</p><p><strong>[14 seconds]</strong></p><h3><a id="slide-7-key-takeaway-1"></a>[SLIDE 7: Key Takeaway]</h3><p><strong>Visual:</strong></p><p>42      # int<br />3.14    # float<br />"42"    # string</p><p><strong>Audio:</strong><br />“Two number types: integers and floats. Don’t put quotes around numbers unless you want text.”</p><p><strong>[10 seconds]</strong></p><p><strong>Total: ~115 seconds</strong></p><h2><a id="video-10-working-with-multiple-variables"></a>Video 10: Working with Multiple Variables</h2><p><strong>Duration:</strong> ~130 seconds<br /><strong>Concept:</strong> Real programs use many variables together (including True/False)</p><h3><a id="slide-1-title-screen-5"></a>[SLIDE 1: Title Screen]</h3><p><strong>Visual:</strong> “Video 10: Working with Multiple Variables”<br /><strong>Audio:</strong><br />“One variable is lonely. Real programs juggle lots of variables at once: username, score, level, settings, inventory—everything. Let’s build a character profile to see how variables work together.”</p><p><strong>[14 seconds]</strong></p><h3><a id="slide-2-character-profile-multiple-types"></a>[SLIDE 2: Character Profile (Multiple Types)]</h3><p><strong>Visual:</strong></p><p>hero_name = "Swift_Shadow_Assassin"<br />hero_level = 1<br />hero_speed = 0.1<br />hero_weapon = "Rusty Spoon"<br />runs_from_combat = True</p><p><strong>Audio:</strong><br />“Meet our hero. Great name… questionable stats. Notice we’re using different types: text for names, numbers for stats, and True/False for behavior. That True/False type is called a Boolean—basically an on/off switch.”</p><p><strong>[20 seconds]</strong></p><h3><a id="slide-3-backpack-pockets-independence"></a>[SLIDE 3: Backpack Pockets (Independence)]</h3><p><strong>Visual:</strong> Backpack pockets labeled with each variable<br /><strong>Audio:</strong><br />“Think of each variable like its own pocket. Weapon pocket, speed pocket, name pocket. Changing one pocket doesn’t magically change the others.”</p><p><strong>[14 seconds]</strong></p><h3><a id="X6363e1f30f86bc4eff33d41d929bf699a6b84f7"></a>[SLIDE 4: Printing Multiple Values (Comma Method)]</h3><p><strong>Visual:</strong></p><p>print("Hero:", hero_name)<br />print("Level:", hero_level)<br />print("Weapon:", hero_weapon)<br />print("Runs from combat:", runs_from_combat)</p><p><strong>Output:</strong></p><p>Hero: Swift_Shadow_Assassin<br />Level: 1<br />Weapon: Rusty Spoon<br />Runs from combat: True</p><p><strong>Audio:</strong><br />“Use commas in print() to show labels and values together. print() handles spacing for you. Clean, readable output.”</p><p><strong>[16 seconds]</strong></p><h3><a id="slide-5-combining-strings-superglue"></a>[SLIDE 5: Combining Strings (Superglue)]</h3><p><strong>Visual:</strong></p><p>title = "The Legendary"<br />full_name = hero_name + " " + title<br />print(full_name)</p><p><strong>Output:</strong></p><p>Swift_Shadow_Assassin The Legendary</p><p><strong>Audio:</strong><br />“You can glue strings together with plus. Some people call this concatenation, but think of it as superglue for text. Here’s how it works: Python takes hero_name—that’s ‘Swift_Shadow_Assassin’—adds a space, then adds ‘The Legendary’. They stick together into one long string. Now our cowardly hero has a properly formatted title.”</p><p><strong>[20 seconds]</strong></p><h3><a id="slide-6-variables-stay-independent"></a>[SLIDE 6: Variables Stay Independent]</h3><p><strong>Visual:</strong></p><p>hero_speed = 0.1<br />enemy_speed = 50.0<br /><br />hero_speed = 0.05<br />print(enemy_speed)  # still 50.0</p><p><strong>Output:</strong></p><p>50.0</p><p><strong>Audio:</strong><br />“Changing hero_speed doesn’t change enemy_speed. Variables don’t affect each other unless you explicitly connect them. They’re separate containers.”</p><p><strong>[14 seconds]</strong></p><h3><a id="slide-7-stay-organized-prefixes"></a>[SLIDE 7: Stay Organized (Prefixes)]</h3><p><strong>Visual:</strong></p><p>player_hp = 50<br />player_xp = 500<br /><br />enemy_hp = 500<br />enemy_xp = 1000</p><p><strong>Audio:</strong><br />“Organization matters. Prefixes like player_ and enemy_ keep your variables from turning into a confusing soup. The player has 50 HP, the enemy has 500. Accidentally swapping those would make for a very short, very one-sided game.”</p><p><strong>[14 seconds]</strong></p><h3><a id="slide-8-key-takeaway-1"></a>[SLIDE 8: Key Takeaway]</h3><p><strong>Visual:</strong> Full character sheet recap<br /><strong>Audio:</strong><br />“Real programs coordinate many variables of different types. Name them clearly, keep them organized, and use them together to describe bigger systems.”</p><p><strong>[10 seconds]</strong></p><p><strong>Total: ~130 seconds</strong></p><p><a id="arc-2-summary"></a></p>